
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>面试总结 | Lastdays&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lastdays">
    

    
    <meta name="description" content="delegate、notification、KVO各优缺点">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结">
<meta property="og:url" content="http://Lastdays.cn/2016/04/21/面试问题总结/index.html">
<meta property="og:site_name" content="Lastdays's Blog">
<meta property="og:description" content="delegate、notification、KVO各优缺点">
<meta property="og:updated_time" content="2016-04-21T11:06:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试总结">
<meta name="twitter:description" content="delegate、notification、KVO各优缺点">

    
    <link rel="alternative" href="feed://lastdays.cn/atom.xml" title="Lastdays&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Lastdays&#39;s Blog" title="Lastdays&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Lastdays&#39;s Blog">Lastdays&#39;s Blog</a></h1>
				<h2 class="blog-motto">我叫LastDays，我有一个心爱的白菜。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About Me</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= null ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/21/面试问题总结/" title="面试总结" itemprop="url">面试总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lastdays" target="_blank" itemprop="author">Lastdays</a>
		
  <p class="article-time">
    <time datetime="2016-04-21T11:06:23.000Z" itemprop="datePublished"> 发表于 2016-04-21</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#delegate_u3001notification_u3001KVO_u5404_u4F18_u7F3A_u70B9"><span class="toc-number">1.</span> <span class="toc-text">delegate、notification、KVO各优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delegate__u7684__u4F18_u52BF__uFF1A"><span class="toc-number">1.1.</span> <span class="toc-text">delegate 的 优势 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7F3A_u70B9__uFF1A"><span class="toc-number">1.2.</span> <span class="toc-text">缺点 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notification__u7684__u4F18_u52BF"><span class="toc-number">1.3.</span> <span class="toc-text">notification 的 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notification_u7684_u7F3A_u70B9"><span class="toc-number">1.4.</span> <span class="toc-text">notification的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO__u7684__u4F18_u52BF__uFF1A"><span class="toc-number">1.5.</span> <span class="toc-text">KVO 的 优势 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO__u7684__u7F3A_u70B9__uFF1A"><span class="toc-number">1.6.</span> <span class="toc-text">KVO 的 缺点 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6548_u7387"><span class="toc-number">1.7.</span> <span class="toc-text">效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5982_u4F55_u624B_u52A8_u89E6_u53D1_u4E00_u4E2Avalue_u7684KVO"><span class="toc-number">2.</span> <span class="toc-text">如何手动触发一个value的KVO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u600E_u4E48_u7528_copy__u5173_u952E_u5B57_uFF1F"><span class="toc-number">3.</span> <span class="toc-text">怎么用 copy 关键字？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block__u4E0E_delegate__u7684_u533A_u522B"><span class="toc-number">4.</span> <span class="toc-text">block 与 delegate 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load__u4E0E_initialize__u7684_u533A_u522B"><span class="toc-number">5.</span> <span class="toc-text">load 与 initialize 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method_swizzle_u539F_u7406"><span class="toc-number">6.</span> <span class="toc-text">method swizzle原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4F7F_u7528_u573A_u666F"><span class="toc-number">6.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swizzling_u5E94_u8BE5_u603B_u662F_u5728+load_u4E2D_u6267_u884C"><span class="toc-number">6.2.</span> <span class="toc-text">Swizzling应该总是在+load中执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swizzling_u5E94_u8BE5_u603B_u662F_u5728dispatch_once_u4E2D_u6267_u884C"><span class="toc-number">6.3.</span> <span class="toc-text">Swizzling应该总是在dispatch_once中执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kvo_u7684_u5B9E_u73B0"><span class="toc-number">6.4.</span> <span class="toc-text">kvo的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isMemberOfClass__u548C_isKindOfClass__u7684_u533A_u522B"><span class="toc-number">7.</span> <span class="toc-text">isMemberOfClass 和 isKindOfClass 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS_u591A_u7EBF_u7A0B_u7F16_u7A0B_u2014_u2014GCD_u4E0ENSOperation_u603B_u7ED3"><span class="toc-number">8.</span> <span class="toc-text">iOS多线程编程——GCD与NSOperation总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-_load_u548Cinitialize_u7684_u5171_u540C_u7279_u70B9"><span class="toc-number">9.</span> <span class="toc-text">1. load和initialize的共同特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-_load_u548Cinitialize_u7684_u4E0D_u540C"><span class="toc-number">10.</span> <span class="toc-text">1. load和initialize的不同</span></a></li></ol>
		
		</div>
		
		<h2 id="delegate_u3001notification_u3001KVO_u5404_u4F18_u7F3A_u70B9"><a href="#delegate_u3001notification_u3001KVO_u5404_u4F18_u7F3A_u70B9" class="headerlink" title="delegate、notification、KVO各优缺点"></a>delegate、notification、KVO各优缺点</h2><a id="more"></a>  
<h3 id="delegate__u7684__u4F18_u52BF__uFF1A"><a href="#delegate__u7684__u4F18_u52BF__uFF1A" class="headerlink" title="delegate 的 优势 ："></a>delegate 的 优势 ：</h3><blockquote>
<ul>
<li>非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。</li>
<li>如果delegate中的一个方法没有实现那么就会出现编译警告/错误</li>
<li>协议必须在controller的作用域范围内定义</li>
<li>在一个应用中的控制流程是可跟踪的并且是可识别的；</li>
<li>在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates</li>
<li>没有第三方对象要求保持/监视通信过程。</li>
<li>能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller</li>
</ul>
</blockquote>
<h3 id="u7F3A_u70B9__uFF1A"><a href="#u7F3A_u70B9__uFF1A" class="headerlink" title="缺点 ："></a>缺点 ：</h3><blockquote>
<ul>
<li>需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义</li>
<li>在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash</li>
<li>在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。</li>
</ul>
</blockquote>
<h3 id="notification__u7684__u4F18_u52BF"><a href="#notification__u7684__u4F18_u52BF" class="headerlink" title="notification 的 优势"></a>notification 的 优势</h3><blockquote>
<ul>
<li>不需要编写多少代码，实现比较简单；</li>
<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>
<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>
</ul>
</blockquote>
<h3 id="notification_u7684_u7F3A_u70B9"><a href="#notification_u7684_u7F3A_u70B9" class="headerlink" title="notification的缺点"></a>notification的缺点</h3><blockquote>
<ul>
<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>
<li>在释放注册的对象时，需要在通知中心取消注册；</li>
<li>在调试的时候应用的工作以及控制过程难跟踪；</li>
<li>需要第三方对喜爱那个来管理controller与观察者对象之间的联系；</li>
<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>
<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>
</ul>
</blockquote>
<h3 id="KVO__u7684__u4F18_u52BF__uFF1A"><a href="#KVO__u7684__u4F18_u52BF__uFF1A" class="headerlink" title="KVO 的 优势 ："></a>KVO 的 优势 ：</h3><blockquote>
<ul>
<li>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；</li>
<li>能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；</li>
<li>能够提供观察的属性的最新值以及先前值；</li>
<li>用key paths来观察属性，因此也可以观察嵌套对象；</li>
<li>完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察</li>
</ul>
</blockquote>
<h3 id="KVO__u7684__u7F3A_u70B9__uFF1A"><a href="#KVO__u7684__u7F3A_u70B9__uFF1A" class="headerlink" title="KVO 的 缺点 ："></a>KVO 的 缺点 ：</h3><ul>
<li>对属性重构将导致我们的观察代码不再可用</li>
<li>官方接口并不好用</li>
</ul>
<h3 id="u6548_u7387"><a href="#u6548_u7387" class="headerlink" title="效率"></a>效率</h3><ul>
<li>肯定是delegate比NSNotification高。</li>
</ul>
<p>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值， 也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含 should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一 步。相反的，notification最大的特色就是不关心接受者的态度， 我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如 NSWindowDidResizeNotification，那么NSWindow对象放出这个notification后就什么都不管了也不会等待接受者的反应。</p>
<ul>
<li>delegate和NSNotification的区别 ：</li>
</ul>
<p>和delegate一样，KVO和NSNotification的作用也是类与类之间的通信，与delegate不同的是1）这两个都是负责发出通知，剩下的事情就不管了，所以没有返回值；2）delegate只是一对一，而这两个可以一对多。这两者也有各自的特点。</p>
<h2 id="u5982_u4F55_u624B_u52A8_u89E6_u53D1_u4E00_u4E2Avalue_u7684KVO"><a href="#u5982_u4F55_u624B_u52A8_u89E6_u53D1_u4E00_u4E2Avalue_u7684KVO" class="headerlink" title="如何手动触发一个value的KVO"></a>如何手动触发一个value的KVO</h2><p>所谓的“手动触发”是区别于“自动触发”：</p>
<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>
<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>
<p>键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context: 会被调用，继而 didChangeValueForKey: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>
<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>
<p>具体做法如下：</p>
<p>如果这个 value 是 表示时间的 self.now ，那么代码如下：最后两行代码缺一不可。</p>
<p>相关代码已放在仓库里。</p>
<h2 id="u600E_u4E48_u7528_copy__u5173_u952E_u5B57_uFF1F"><a href="#u600E_u4E48_u7528_copy__u5173_u952E_u5B57_uFF1F" class="headerlink" title="怎么用 copy 关键字？"></a>怎么用 copy 关键字？</h2><p>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<h2 id="block__u4E0E_delegate__u7684_u533A_u522B"><a href="#block__u4E0E_delegate__u7684_u533A_u522B" class="headerlink" title="block 与 delegate 的区别"></a>block 与 delegate 的区别</h2><p>delegate运行成本低。block成本很高的。而且delegate是经典设计模式也就是大部分的语言都可以实现的模式，相对block出现比较早。<br>block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是加计数，使用完或者block置nil后才消除。delegate只是保存了一个对象指针，直接回调，没有额外消耗。相对C的函数指针，只多做了一个查表动作</p>
<p>## </p>
<p>根据苹果文档对Runtime的解释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL _cmd, ...)</span><br><span class="line">将一个消息发送给一个对象，并且返回一个值。</span><br><span class="line">self是消息的接受者，</span><br><span class="line">_cmd是selector，</span><br><span class="line">…是可变参数列表。</span><br></pre></td></tr></table></figure>
<p><a href="http://lastdays.cn/2016/02/20/runtime2/">消息转发和发送</a></p>
<h2 id="load__u4E0E_initialize__u7684_u533A_u522B"><a href="#load__u4E0E_initialize__u7684_u533A_u522B" class="headerlink" title="load 与 initialize 的区别"></a>load 与 initialize 的区别</h2><p>load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。<br>load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。<br>load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。<br>load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</p>
<p>文／bestswifter（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/d25f691f0b07" target="_blank" rel="external">http://www.jianshu.com/p/d25f691f0b07</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
<h2 id="method_swizzle_u539F_u7406"><a href="#method_swizzle_u539F_u7406" class="headerlink" title="method swizzle原理"></a>method swizzle原理</h2><h3 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h3><p>我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p>
<h3 id="Swizzling_u5E94_u8BE5_u603B_u662F_u5728+load_u4E2D_u6267_u884C"><a href="#Swizzling_u5E94_u8BE5_u603B_u662F_u5728+load_u4E2D_u6267_u884C" class="headerlink" title="Swizzling应该总是在+load中执行"></a>Swizzling应该总是在+load中执行</h3><p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<h3 id="Swizzling_u5E94_u8BE5_u603B_u662F_u5728dispatch_once_u4E2D_u6267_u884C"><a href="#Swizzling_u5E94_u8BE5_u603B_u662F_u5728dispatch_once_u4E2D_u6267_u884C" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>
<h3 id="kvo_u7684_u5B9E_u73B0"><a href="#kvo_u7684_u5B9E_u73B0" class="headerlink" title="kvo的实现"></a>kvo的实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">        static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];         </span><br><span class="line">        // When swizzling a class method, use the following:</span><br><span class="line">                    // Class class = object_getClass((id)self);</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line">                    SEL swizzledSelector = @selector(xxx_viewWillAppear:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">                    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        BOOL didAddMethod =</span><br><span class="line">                        class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">                        class_replaceMethod(class,</span><br><span class="line">                swizzledSelector,</span><br><span class="line">                method_getImplementation(originalMethod),</span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isMemberOfClass__u548C_isKindOfClass__u7684_u533A_u522B"><a href="#isMemberOfClass__u548C_isKindOfClass__u7684_u533A_u522B" class="headerlink" title="isMemberOfClass 和 isKindOfClass 的区别"></a>isMemberOfClass 和 isKindOfClass 的区别</h2><p>isKindOfClass和isMemberOfClass之间的区别是：<br>我们可以使用isKindOfClass来确定一个对象是否是一个类的实例，或者是该类祖先类的实例。<br>isMemberOfClass只能用来判断前者，不能用来判断后者。</p>
<p>可以说：isMemberOfClass不能检测任何的类都是基于NSObject类这一事实，而isKindOfClass可以。</p>
<h2 id="iOS_u591A_u7EBF_u7A0B_u7F16_u7A0B_u2014_u2014GCD_u4E0ENSOperation_u603B_u7ED3"><a href="#iOS_u591A_u7EBF_u7A0B_u7F16_u7A0B_u2014_u2014GCD_u4E0ENSOperation_u603B_u7ED3" class="headerlink" title="iOS多线程编程——GCD与NSOperation总结"></a>iOS多线程编程——GCD与NSOperation总结</h2><p>其实，如果不考虑其他任何因素和技术，多线程有百害而无一利，只能浪费时间，降低程序效率。</p>
<p>是的，我很清醒的写下这句话。</p>
<p>试想一下，一个任务由十个子任务组成。现在有两种方式完成这个任务： 1. 建十个线程，把每个子任务放在对应的线程中执行。执行完一个线程中的任务就切换到另一个线程。 </p>
<ol>
<li>把十个任务放在一个线程里，按顺序执行。</li>
</ol>
<p>操作系统的基础知识告诉我们，线程，是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是“一个CPU执行的一条无分叉的命令列”。</p>
<p>对于第一种方法，在十个线程之间来回切换，就意味着有十组栈和寄存器中<br>的值需要不断地被备份、替换。 而对于对于第二种方法，只有一组寄存器和栈存在，显然效率完胜前者</p>
<p>GCD:</p>
<p>三种队列：<br>串行队列（先进入队列的任务先出队列，每次只执行一个任务）<br>并发队列（依然是“先入先出”，不过可以形成多个任务并发）<br>主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）<br>两种执行方式：<br>同步执行<br>异步执行</p>
<p><a href="https://bestswifter.com/multithreadconclusion/" target="_blank" rel="external">iOS多线程编程——GCD与NSOperation总结</a></p>
<ol>
<li>为什么要有 runtime？</li>
<li>在 .m 文件的@implementation外面定义一个 static NSArray *array？</li>
<li>runtime 如何实现 weak 属性 ？</li>
<li>objc中向一个nil对象发送消息将会发生什么？</li>
<li>selector,IMP 和 Method</li>
<li>能否向编译后得到的类中增加实例变量？能否在运行时向类中添加实例变量(无论在MRC下还是ARC下均不需要手动释放)？能否在运行时添加实例方法</li>
</ol>
<p>typedef struct objc_method *Method;  </p>
<p>struct objc_method {<br>    SEL method_name;        // 方法名称<br>    charchar *method_typesE;    // 参数和返回类型的描述字串<br>    IMP method_imp;         // 方法的具体的实现的指针<br>}  </p>
<p>runtime对注册的类，会进行布局，对于weak对象会放入一个hash表中，用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，加入weak指向的对象内存地址是a，那么就以a为键，在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。 （网上看到的。。）</p>
<h2 id="1-_load_u548Cinitialize_u7684_u5171_u540C_u7279_u70B9"><a href="#1-_load_u548Cinitialize_u7684_u5171_u540C_u7279_u70B9" class="headerlink" title="1. load和initialize的共同特点"></a>1. load和initialize的共同特点</h2><ul>
<li>在不考虑开发者主动使用的情况下，系统最多会调用一次</li>
<li>如果父类和子类都被调用，父类的调用一定在子类之前</li>
<li>都是为了应用运行提前创建合适的运行环境</li>
<li>在使用时都不要过重地依赖于这两个方法，除非真正必要</li>
</ul>
<h2 id="1-_load_u548Cinitialize_u7684_u4E0D_u540C"><a href="#1-_load_u548Cinitialize_u7684_u4E0D_u540C" class="headerlink" title="1. load和initialize的不同"></a>1. load和initialize的不同</h2><ol>
<li>load方法相关要点</li>
</ol>
<p>废话不多说，直接上要点列表：</p>
<ul>
<li>调用时机比较早，运行环境有不确定因素。具体说来，在iOS上通常就是App启动时进行加载，但当load调用的时候，并不能保证所有类都加载完成且可用，必要时还要自己负责做auto release处理。</li>
<li>补充上面一点，对于有依赖关系的两个库中，被依赖的类的load会优先调用。但在一个库之内，调用顺序是不确定的。</li>
<li>对于一个类而言，没有load方法实现就不会调用，不会考虑对NSObject的继承。</li>
<li>一个类的load方法不用写明[super load]，父类就会收到调用，并且在子类之前。</li>
<li>Category的load也会收到调用，但顺序上在主类的load调用之后。</li>
<li>不会直接触发initialize的调用。</li>
</ul>
<ol>
<li>initialize方法相关要点</li>
</ol>
<p>同样，直接整理要点：</p>
<ul>
<li>initialize的自然调用是在第一次主动使用当前类的时候（lazy，这一点和Java类的“clinit”的很像）。</li>
<li>在initialize方法收到调用时，运行环境基本健全。</li>
<li>initialize的运行过程中是能保证线程安全的。</li>
<li>和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用。</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://Lastdays.cn/2016/04/21/面试问题总结/" data-title="面试总结 | Lastdays&#39;s Blog" data-tsina="5848341536" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/04/08/KVO/"  title="探索KVO（使用-&gt;设计）">
 <strong>下一篇：</strong><br/> 
 <span>探索KVO（使用-&gt;设计）
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/04/21/面试问题总结/" data-title="面试总结" data-url="http://Lastdays.cn/2016/04/21/面试问题总结/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#delegate_u3001notification_u3001KVO_u5404_u4F18_u7F3A_u70B9"><span class="toc-number">1.</span> <span class="toc-text">delegate、notification、KVO各优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delegate__u7684__u4F18_u52BF__uFF1A"><span class="toc-number">1.1.</span> <span class="toc-text">delegate 的 优势 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7F3A_u70B9__uFF1A"><span class="toc-number">1.2.</span> <span class="toc-text">缺点 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notification__u7684__u4F18_u52BF"><span class="toc-number">1.3.</span> <span class="toc-text">notification 的 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notification_u7684_u7F3A_u70B9"><span class="toc-number">1.4.</span> <span class="toc-text">notification的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO__u7684__u4F18_u52BF__uFF1A"><span class="toc-number">1.5.</span> <span class="toc-text">KVO 的 优势 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO__u7684__u7F3A_u70B9__uFF1A"><span class="toc-number">1.6.</span> <span class="toc-text">KVO 的 缺点 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6548_u7387"><span class="toc-number">1.7.</span> <span class="toc-text">效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5982_u4F55_u624B_u52A8_u89E6_u53D1_u4E00_u4E2Avalue_u7684KVO"><span class="toc-number">2.</span> <span class="toc-text">如何手动触发一个value的KVO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u600E_u4E48_u7528_copy__u5173_u952E_u5B57_uFF1F"><span class="toc-number">3.</span> <span class="toc-text">怎么用 copy 关键字？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block__u4E0E_delegate__u7684_u533A_u522B"><span class="toc-number">4.</span> <span class="toc-text">block 与 delegate 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load__u4E0E_initialize__u7684_u533A_u522B"><span class="toc-number">5.</span> <span class="toc-text">load 与 initialize 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method_swizzle_u539F_u7406"><span class="toc-number">6.</span> <span class="toc-text">method swizzle原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4F7F_u7528_u573A_u666F"><span class="toc-number">6.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swizzling_u5E94_u8BE5_u603B_u662F_u5728+load_u4E2D_u6267_u884C"><span class="toc-number">6.2.</span> <span class="toc-text">Swizzling应该总是在+load中执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swizzling_u5E94_u8BE5_u603B_u662F_u5728dispatch_once_u4E2D_u6267_u884C"><span class="toc-number">6.3.</span> <span class="toc-text">Swizzling应该总是在dispatch_once中执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kvo_u7684_u5B9E_u73B0"><span class="toc-number">6.4.</span> <span class="toc-text">kvo的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isMemberOfClass__u548C_isKindOfClass__u7684_u533A_u522B"><span class="toc-number">7.</span> <span class="toc-text">isMemberOfClass 和 isKindOfClass 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS_u591A_u7EBF_u7A0B_u7F16_u7A0B_u2014_u2014GCD_u4E0ENSOperation_u603B_u7ED3"><span class="toc-number">8.</span> <span class="toc-text">iOS多线程编程——GCD与NSOperation总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-_load_u548Cinitialize_u7684_u5171_u540C_u7279_u70B9"><span class="toc-number">9.</span> <span class="toc-text">1. load和initialize的共同特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-_load_u548Cinitialize_u7684_u4E0D_u540C"><span class="toc-number">10.</span> <span class="toc-text">1. load和initialize的不同</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Blocks/" title="Blocks">Blocks<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Runtime/" title="Runtime">Runtime<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tools/" title="Tools">Tools<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/控件设计优化/" title="控件设计优化">控件设计优化<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/生活/" title="生活">生活<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/面试题/" title="面试题">面试题<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Objective—C消息发送与转发/" title="Objective—C消息发送与转发">Objective—C消息发送与转发<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C类和对象的实现原理/" title="Objective-C类和对象的实现原理">Objective-C类和对象的实现原理<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.devtf.cn" target="_blank" title="高质量技术文章的聚合网站">开发者技术前线</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/40e4dced948f/latest_articles" target="_blank" title="大V的博客">kuailejim</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/9c51a213b02e/latest_articles" target="_blank" title="好友">Martin_wjl</a>
            
          </li>
        
          <li>
            
            	<a href="https://bestswifter.com" target="_blank" title="好友">bestswifter</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="feed://lastdays.cn/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5848341536&verifier=b03f6446&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 我叫Lastdays，一个喜欢iOS的90后，单线程的iOS开发男孩. <br/>
			感谢我有一个师傅</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5848341536" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/MrLoong" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:lastdays1122@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Lastdays">Lastdays</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"lastdayss"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cf7f851be66540259af32ff62b1cda71";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
