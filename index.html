
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Lastdays</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lastdays">
    

    
    <meta name="description" content="欢迎来到白菜的世界">
<meta property="og:type" content="website">
<meta property="og:title" content="Lastdays">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lastdays">
<meta property="og:description" content="欢迎来到白菜的世界">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lastdays">
<meta name="twitter:description" content="欢迎来到白菜的世界">

    
    <link rel="alternative" href="/atom.xml" title="Lastdays" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Lastdays" title="Lastdays"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Lastdays">Lastdays</a></h1>
				<h2 class="blog-motto">欢迎来到一个喜欢白菜的90后的世界</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= null ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/04/HttpLibrary/" title="编写iOS HTTP网络请求库" itemprop="url">编写iOS HTTP网络请求库</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lastdays" target="_blank" itemprop="author">Lastdays</a>
		
  <p class="article-time">
    <time datetime="2016-02-03T16:36:23.000Z" itemprop="datePublished"> 发表于 2016-02-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="u4E00_u6B65_u4E00_u6B65_u642D_u5EFA_u81EA_u5DF1_u7684iOS_u7F51_u7EDC_u8BF7_u6C42_u5E93_uFF08_u4E00_uFF09"><a href="#u4E00_u6B65_u4E00_u6B65_u642D_u5EFA_u81EA_u5DF1_u7684iOS_u7F51_u7EDC_u8BF7_u6C42_u5E93_uFF08_u4E00_uFF09" class="headerlink" title="一步一步搭建自己的iOS网络请求库（一）"></a>一步一步搭建自己的iOS网络请求库（一）</h1><p>大家好，我是LastDay，终于有了自己的博客，在这里分享一个的HTTP请求库的编写经验。</p>
<h2 id="u7B80_u5355_u7684_u4ECB_u7ECD"><a href="#u7B80_u5355_u7684_u4ECB_u7ECD" class="headerlink" title="简单的介绍"></a>简单的介绍</h2><p>介绍一下，NSURLSession是iOS7中新的网络接口，它与NSURLConnection是并列的。在程序在前台时，NSURLSession与NSURLConnection可以互为替代工作。两者在前台的时候其实没有什么区别，最主要的是程序在进入后台的时候，Background Session会更加灵活</p>
<h2 id="u6D4B_u8BD5NSURLSession"><a href="#u6D4B_u8BD5NSURLSession" class="headerlink" title="测试NSURLSession"></a>测试NSURLSession</h2><p>首先我们来新建一个工程，起名为LyHttp，在页面上放置一个按钮 ，起名为”测试”。</p>
<p><img src="http://img.blog.csdn.net/20151130224816040" alt=""></p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/02/04/HttpLibrary/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/04/HttpLibrary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/04/HttpLibrary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/03/TCP/" title="TCP协议总结" itemprop="url">TCP协议总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lastdays" target="_blank" itemprop="author">Lastdays</a>
		
  <p class="article-time">
    <time datetime="2016-02-03T13:25:43.000Z" itemprop="datePublished"> 发表于 2016-02-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="u4F20_u8F93_u5C42_u6982_u8FF0"><a href="#u4F20_u8F93_u5C42_u6982_u8FF0" class="headerlink" title="传输层概述"></a>传输层概述</h2><p>TCP协议特点：面向连接、字节流、可靠传输</p>
<h3 id="u9762_u5411_u94FE_u63A5_uFF1A"><a href="#u9762_u5411_u94FE_u63A5_uFF1A" class="headerlink" title="面向链接："></a>面向链接：</h3><p>1.使用TCP协议的双方必须先建立连接，并且双方都必须分配相应的内核资源。TCP的连接是全双工的，也就是说双方可以根据一个连接进行读写操作。</p>
<h3 id="u5B57_u8282_u6D41_uFF1A"><a href="#u5B57_u8282_u6D41_uFF1A" class="headerlink" title="字节流："></a>字节流：</h3><p>1.当发送方应用多次进行写操作的时候，TCP发送模块会先把数据放在发送缓冲区中，当TCP发送模块真正发送的时候，这些在发送缓冲区中的数据才可能被封装成一个或多个报文段发出。所有根据以上结论，应用程序执行的写操作的次数和TCP发送的报文段个数没有对应的数量关系。</p>
<p>2.当接收端收到一个或多个报文段数据后，TCP模块必须把它们携带的应用层数据必须按照报文段序号把它们放到TCP接受缓冲区中。同时通知应用程序读取数据，这样应用程序就可以一次读出数据或多次读出数据，这取决于应用程序读缓冲区的大小。根据以上结论得出，TCP读取操作的次数跟接收报文段个数也没有固定的关系</p>
<p><strong>总结：发送端执行的写操作次数与接受端的读操作次数没有任何数量关系，应用程序的发送和接收是没有边界限制的，UDP就不是这样，在这里不详细说了</strong></p>
<p>如图TCP字节流服务过程：</p>
<p><img src="http://img.blog.csdn.net/20150801192657747" alt="字节流传输"></p>
<p>以上就是字节流服务过程：</p>
<p>从图中我们就可以看见，发送短调用的发送次数，和接收短的接受次数并不一样。所有的数据都是先进入缓冲区，在进行操作。封装成报文段进行发送或接收。</p>
<h3 id="u53EF_u9760_u4F20_u8F93"><a href="#u53EF_u9760_u4F20_u8F93" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP协议是可靠的传输协议，支持这种可靠传输的机制有：</p>
<ul>
<li>发送应答机制：也就是说发送端发送的每个数据报文段都必须得到接收方的应答。</li>
<li>超时从穿机制：也就是说发送端在发送报文段数据后，本身就启动计时器，如果在规定时间内没有接到接受端的应答，那么就会重新发送这段数据。</li>
</ul>
<h2 id="u8981_u4E86_u89E3TCP_u5728_u6574_u4E2ATCP_u534F_u8BAE_u6808_u4E2D_u7684_u4F5C_u7528_u6211_u4EEC_u9700_u8981_u5206_u6790_u4E00_u4E0BTCP_u5934_u90E8_u7ED3_u6784_uFF1A"><a href="#u8981_u4E86_u89E3TCP_u5728_u6574_u4E2ATCP_u534F_u8BAE_u6808_u4E2D_u7684_u4F5C_u7528_u6211_u4EEC_u9700_u8981_u5206_u6790_u4E00_u4E0BTCP_u5934_u90E8_u7ED3_u6784_uFF1A" class="headerlink" title="要了解TCP在整个TCP协议栈中的作用我们需要分析一下TCP头部结构："></a>要了解TCP在整个TCP协议栈中的作用我们需要分析一下TCP头部结构：</h2><p><img src="http://img.blog.csdn.net/20150801194315541" alt="这里写图片描述"></p>
<ul>
<li>头部结构出现在每个TCP报文段中</li>
<li>头部结构包括20个字节的固定结构和40个字节的头部选项字段</li>
<li>16位源端口：该报文段数据来自哪里？</li>
<li>16位目的端口：该报文段数据传给哪个上层协议或应用程序。客户端基本使用临时端口号，而服务器选择知名的服务端口号，在Linux下，所有的知名服务端口号都定义在/etc/services文件夹下。<br>HTTP服务端口号为80，DNS服务端口号为53，FTP服务器端口为21。</li>
<li>32位序号：在tcp一次通信中（从建立连接到断开），在TCP协议在发送数据时会根据实际传输能力把数据分割成若干数据段，这32位序列号就是为这个数据段打上标记。</li>
<li>32位确认号：如果接收端没有接收到某一段数据会告诉发送端：“我没收到这段数据 请重新发送” 所以用确认号能保证数据的完整性 </li>
<li>4位头部长度：标识有多少个4字节</li>
<li>URG：紧急指针是否有效</li>
<li>ACK：表示确认号是否有效</li>
<li>PSH：提示接收端应用程序应该立即从接收缓冲区中读取数据，为接收后续数据腾出空间。</li>
<li>RST：要求对方重新建立连接。</li>
<li>SYN：请求建立一个连接</li>
<li>FIN：同对方本端要关闭连接。</li>
<li>16位窗口大小：TCP流量控制。</li>
<li>16位校验和：接受端对tcp数据进行CRC算法检验tcp报文段在发送的过程中属否损坏。（包括数据部分）</li>
<li>16位紧急指针：表示最后一个紧急数据的下一字节的序号。</li>
<li>头部选项：最多包涵40个字节</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150801201537796" alt="这里写图片描述"></p>
<pre><code>1.kind：说明选项类型。

2.length：表示该选项的总长度。

3.info：选项的具体信息。
</code></pre><p>kind类型如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150801201650363" alt="这里写图片描述"></p>
<h1 id="TCP_u8FDE_u63A5_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B"><a href="#TCP_u8FDE_u63A5_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B" class="headerlink" title="TCP连接状态转移过程"></a>TCP连接状态转移过程</h1><h2 id="u670D_u52A1_u5668_u5178_u578B_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B"><a href="#u670D_u52A1_u5668_u5178_u578B_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B" class="headerlink" title="服务器典型状态转移过程"></a>服务器典型状态转移过程</h2><p>1、首先服务器通过LISTEN系统调用，进入LISTEN状态，表示被动打开，被动等待客户端的连接，服务器监听到某个客户端的连接请求后，这个连接请求被称为同步报文段。之后TCP会将其放到内核等待队列中，并向客户端发送带SYN的确认报文段，之后该连接就会处于SYN_RCVD状态。那么这个时候如果服务器收到了客户端的ACK确认报文段，服务器进入ESTABLISHED，这个状态可以让双方进行数据传输。</p>
<h2 id="u670D_u52A1_u5668_u5173_u95ED_u72B6_u6001_u7684_u8F6C_u79FB_u8FC7_u7A0B"><a href="#u670D_u52A1_u5668_u5173_u95ED_u72B6_u6001_u7684_u8F6C_u79FB_u8FC7_u7A0B" class="headerlink" title="服务器关闭状态的转移过程"></a>服务器关闭状态的转移过程</h2><p>1、当客户端主动关闭连接时，客户端主动调用CLOSE，服务器接收到客户端的关闭报文段后，服务器返回ACK确认报文段，是连接进入CLOSE_WAIT状态。这个状态的就是跟字面意思一样，等待服务器关闭连接。这个时候服务器也会给客户端发送一个结束报文段，这个时候进入LAST_ACK。接下来就是等待客户端结束连接的最后一次确认。</p>
<h2 id="u5BA2_u6237_u7AEF_u8FDE_u63A5_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B"><a href="#u5BA2_u6237_u7AEF_u8FDE_u63A5_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B" class="headerlink" title="客户端连接状态转移过程"></a>客户端连接状态转移过程</h2><p>1、首先客户端通过CONNECT系统调用，给服务器发送同步报文段。使系统进入YSN_SENT状态。接下来会有两种可能，如果连接失败，该连接将会恢复到CLOSED状态，如果该客户多收到服务器返回的同步报文段，确认报文段，说明该客户端成功连接服务器。连接转移到ESTABLISHED状态（功能通上）</p>
<h2 id="u5F53_u5BA2_u6237_u7AEF_u8FDB_u884C_u5173_u95ED_u65F6_u7684_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B"><a href="#u5F53_u5BA2_u6237_u7AEF_u8FDB_u884C_u5173_u95ED_u65F6_u7684_u72B6_u6001_u8F6C_u79FB_u8FC7_u7A0B" class="headerlink" title="当客户端进行关闭时的状态转移过程"></a>当客户端进行关闭时的状态转移过程</h2><p>1、当客户端关闭时，客户端发送一个关闭连接报文段，同时连接进入SFIN_WAIT_1状态，如果接收到服务端ACK确认，连接状态进入FIN_WAIT_2状态。当服务端也发送了结束报文段，那么客户端也会发送ACK确认，客户端进入TIME_WAIT状态。</p>
<h3 id="u5982_u56FE_u4E3ATCP_u8FDE_u63A5_u72B6_u6001_u8F6C_u79FB_u56FE_uFF1A"><a href="#u5982_u56FE_u4E3ATCP_u8FDE_u63A5_u72B6_u6001_u8F6C_u79FB_u56FE_uFF1A" class="headerlink" title="如图为TCP连接状态转移图："></a>如图为TCP连接状态转移图：</h3><p><img src="http://img.blog.csdn.net/20150802110224571" alt="这里写图片描述"></p>
<p>参照图片详细了解连接转移过程</p>
<h1 id="TCP_u5EFA_u7ACB_u8FDE_u63A5_u548C_u5173_u95ED_u8FDE_u63A5_u7684_u8FC7_u7A0B"><a href="#TCP_u5EFA_u7ACB_u8FDE_u63A5_u548C_u5173_u95ED_u8FDE_u63A5_u7684_u8FC7_u7A0B" class="headerlink" title="TCP建立连接和关闭连接的过程"></a>TCP建立连接和关闭连接的过程</h1><p>首先我们来回顾下我们以前了解过的，TCP头部结构有6个标识位</p>
<ul>
<li>SYN：仅在三次握手建立连接时有效，表示同步报文段。</li>
<li>ACK：对TCP请求的确认标志。</li>
<li>FIN：标志用来结束一个TCP连接，标识此报文段是一个结束报文段</li>
</ul>
<p>以上就是我们讲到以下内容的时候需要用到的知识点</p>
<h2 id="u4E09_u6B21_u63E1_u624B_u5EFA_u7ACB_u8FDE_u63A5"><a href="#u4E09_u6B21_u63E1_u624B_u5EFA_u7ACB_u8FDE_u63A5" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><p>开始介绍一下三次握手的过程：</p>
<ul>
<li>第一次握手：其实是客户端发送一个带有SYN的数据报文段发送给服务器，对应在图片中就是从主机A－&gt;主机B（SYN＝1，seq＝i），seq为对应序列号为i。之后主机A进入SYN_SENT状态。同时等待服务器的确认</li>
<li>第二次握手：服务器收到同步报文段后（也就是带有SYN的同步报文段），必须确定客户的同步报文段。然后自己也发送一个带有SYN的报文段，对应到图片中也就死第二个报文段，其中SYN＝1，表示这是一个同步报文段，ACK＝1，表示这是一个确认报文段，确认序号值为i+1，序号值为j。</li>
<li>第三次握手：这次就是客户端收到确认同步报文段后，它向服务器发送确认包，对应到图片中也就是第三个报文段，ack＝1也就是表示这是一个确认报文段，确认序号为j+1</li>
</ul>
<p>三次握手建立后，客户端与服务器开始传送数据。</p>
<p>三次握手示意图：</p>
<p><img src="http://img.blog.csdn.net/20150803153852016" alt="这里写图片描述"></p>
<h2 id="u56DB_u6B21_u63E1_u624B_u5173_u95ED_u8FDE_u63A5"><a href="#u56DB_u6B21_u63E1_u624B_u5173_u95ED_u8FDE_u63A5" class="headerlink" title="四次握手关闭连接"></a>四次握手关闭连接</h2><p>接下来，我们来介绍下四次握手关闭</p>
<ul>
<li>第一次握手：表示客户端A发送给服务器一个带有SYN的结束报文段，用来关闭客户端A到服务端B的数据传送，对应到图片中也就是第一个报文段，FIN＝1，seq＝i，表示一个结束报文段</li>
<li>第二次握手：服务端B接收到这个结束报文段后，它返回一个确认报文段，对应到图片中就是第二个确认报文段。其中ACK＝1，ack＝i+i，表示一个确认报文段，确认序号为i+1.</li>
<li>第三次握手：服务器B关闭与客户端A的连接，他发送一个带有SYN结束报文段，对应图片上第三个报文段，其中  SYN＝1，seq＝j，表示结束报文段，序号为j。</li>
<li>第四次握手：客户端A返回一个确认报文段，其中确认序号为j+1，对应图片上为第四个报文段，ACK＝1，ack＝j+1。</li>
</ul>
<h3 id="u603B_u7ED3_uFF1A_u4E3A_u4EC0_u4E48_u5EFA_u7ACB_u8FDE_u63A5_u9700_u8981_u4E09_u6B21_u63E1_u624B_uFF1F_u4E3A_u4EC0_u4E48_u5173_u95ED_u8FDE_u63A5_u9700_u8981_u56DB_u6B21_u63E1_u624B_uFF1F_u4E3A_u4EC0_u4E48_u5EFA_u7ACB_u8FDE_u63A5_u9700_u8981_u4E09_u6B21_u63E1_u624B_u5462_uFF1F"><a href="#u603B_u7ED3_uFF1A_u4E3A_u4EC0_u4E48_u5EFA_u7ACB_u8FDE_u63A5_u9700_u8981_u4E09_u6B21_u63E1_u624B_uFF1F_u4E3A_u4EC0_u4E48_u5173_u95ED_u8FDE_u63A5_u9700_u8981_u56DB_u6B21_u63E1_u624B_uFF1F_u4E3A_u4EC0_u4E48_u5EFA_u7ACB_u8FDE_u63A5_u9700_u8981_u4E09_u6B21_u63E1_u624B_u5462_uFF1F" class="headerlink" title="总结：为什么建立连接需要三次握手？为什么关闭连接需要四次握手？为什么建立连接需要三次握手呢？"></a>总结：为什么建立连接需要三次握手？为什么关闭连接需要四次握手？为什么建立连接需要三次握手呢？</h3><ul>
<li><p>接受连接缺需要4次握手，LISTEN状态下建立连接后，它可以把同步报文段和确认报文段合并成一个报文段来进行发送，确认报文段起到应达作用，同步报文段起到同步作用，也就是三次握手中的第二个报文段其实是发挥了两个作用</p>
</li>
<li><p>在关闭连接时，当收到对方的结束报文段时，表示对方没有数据发给你了，但是自己的数据未必全部发送完毕，所以你可能还需要继续发送一些数据之后在发送结束报文段给对方了表示你同意现在可以断开连接，所以关闭连接需要四次握手</p>
</li>
<li><p>如果把三次握手改成两次握手，就有可能发生死锁。关于死锁，（搜索一下）</p>
</li>
</ul>
<p>四次握手示意图：</p>
<p><img src="http://img.blog.csdn.net/20150803153635912" alt="这里写图片描述"></p>
<h2 id="TIME_WAIT_u72B6_u6001_u7684_u542B_u4E49"><a href="#TIME_WAIT_u72B6_u6001_u7684_u542B_u4E49" class="headerlink" title="TIME_WAIT状态的含义"></a>TIME_WAIT状态的含义</h2><p>在TCP详解（二）中，提到过，当客户端收到服务器的结束报文段后，不会立即进入CLOSED状态，而是转移到TIME_WAIT状态下，在这个状态下，客户端要等待一段2倍的MSL（报文段最大生存时间）时间。等待这个时间后才能完全关闭。TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活msl秒即被丢弃，另一个方向上的应答最多存活msl秒也被丢弃。 通过实施这个规则，我们就能保证每成功建立一个TCP连接时。来自该链接先前化身的重复分组都已经在网络中消逝了。</p>
<h3 id="TIME_WAIT_u72B6_u6001_u5B58_u5728_u7684_u539F_u56E0_u6709_u4E24_u70B9_uFF1A"><a href="#TIME_WAIT_u72B6_u6001_u5B58_u5728_u7684_u539F_u56E0_u6709_u4E24_u70B9_uFF1A" class="headerlink" title="TIME_WAIT状态存在的原因有两点："></a>TIME_WAIT状态存在的原因有两点：</h3><ul>
<li><p>可靠的终止TCP连接:</p>
<p>  例如在四次握手时，如果第三个报文段丢失，这个时候服务器将重新发送这个报文段，所以客户端需要停留在摸个状态来处理重复信息。否则客户端将会向服务器发送复位报文段，让服务器误认为这是一个错误</p>
</li>
<li><p>保证延迟来的TCP报文段有足够的时间去识别并丢弃:</p>
<p>  在Linux系统上，一个TCP端口不能被同时打开多次，当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用的端口建立一个新连接。<br>  但是我们反过来考虑，如果不存在这种机制，那么服务器刚关闭连接，又建立了一个类似的连接，成为“原链接化身”，这个“化身“就有可能就收到属于原来连接的数据报文段，这种情况是不允许出现的。</p>
</li>
</ul>
<h3 id="IME_WAIT_u72B6_u6001_u8FC7_u591A_u7684_u7F3A_u70B9_uFF1A"><a href="#IME_WAIT_u72B6_u6001_u8FC7_u591A_u7684_u7F3A_u70B9_uFF1A" class="headerlink" title="IME_WAIT状态过多的缺点："></a>IME_WAIT状态过多的缺点：</h3><ul>
<li>根据上诉，我们可以了解到，如果IME_WAIT状态过多会占用大量的端口号，占用系用资源</li>
</ul>
<h3 id="IME_WAIT_u72B6_u6001_u8FC7_u591A_u7684_u5904_u7406_u65B9_u6CD5"><a href="#IME_WAIT_u72B6_u6001_u8FC7_u591A_u7684_u5904_u7406_u65B9_u6CD5" class="headerlink" title="IME_WAIT状态过多的处理方法"></a>IME_WAIT状态过多的处理方法</h3><ul>
<li><p>修改内核参数</p>
</li>
<li><p>尽可能被动关闭连接</p>
</li>
<li><p>将长连接修改为短连接</p>
</li>
<li><p>通过套接字选项尽可能回避IME_WAIT状态带来的负面影响</p>
</li>
</ul>
<h1 id="RST_u590D_u4F4D_u62A5_u6587_u6BB5"><a href="#RST_u590D_u4F4D_u62A5_u6587_u6BB5" class="headerlink" title="RST复位报文段"></a>RST复位报文段</h1><h2 id="RST_u590D_u4F4D_u62A5_u6587_u6BB5_u7684_u4F5C_u7528"><a href="#RST_u590D_u4F4D_u62A5_u6587_u6BB5_u7684_u4F5C_u7528" class="headerlink" title="RST复位报文段的作用"></a>RST复位报文段的作用</h2><p>曾经在<a href="http://blog.csdn.net/lastdays_l/article/details/47189621" target="_blank" rel="external">TCP协议详解（一）</a>中介绍了TCP的头部信息，头部中有6位的标识字段，这6位中有一位时RST标志位。如果在TCP某一个报文段中，RST的标志位＝1，就说明这个报文段是RST报文段，也就是复位报文段，在某些情况下，TCP连接的一端会像另一端发送携带RST数据报文段，用来通知对方关闭连接或者重新连接。</p>
<p>RST报文段是请求对方连接，发送此报文段的时机有：</p>
<ul>
<li>在连接建立时</li>
<li>在中间发送数据时</li>
<li>在连接关闭时</li>
</ul>
<p>以上三种情况都有可能发送RST复位报文段。</p>
<h2 id="u53D1_u9001RST_u62A5_u6587_u6BB5_u60C5_u51B5"><a href="#u53D1_u9001RST_u62A5_u6587_u6BB5_u60C5_u51B5" class="headerlink" title="发送RST报文段情况"></a>发送RST报文段情况</h2><h3 id="RST_u590D_u4F4D_u62A5_u6587_u6BB5_u51FA_u73B0_u7684_u539F_u56E0_u5F88_u591A_uFF0C_u5728_u7F51_u8DEF_u7F16_u7A0B_u4E2D_uFF0C_u4E5F_u5F88_u96BE_u6392_u67E5_u539F_u56E0_u5728_u54EA_uFF1F_u6240_u4EE5_u5217_u51FA_u4E00_u4E9B_u5E38_u89C1_u7684_u539F_u56E0_uFF0C_u5206_u4EAB_u7ED9_u5927_u5BB6_uFF1A"><a href="#RST_u590D_u4F4D_u62A5_u6587_u6BB5_u51FA_u73B0_u7684_u539F_u56E0_u5F88_u591A_uFF0C_u5728_u7F51_u8DEF_u7F16_u7A0B_u4E2D_uFF0C_u4E5F_u5F88_u96BE_u6392_u67E5_u539F_u56E0_u5728_u54EA_uFF1F_u6240_u4EE5_u5217_u51FA_u4E00_u4E9B_u5E38_u89C1_u7684_u539F_u56E0_uFF0C_u5206_u4EAB_u7ED9_u5927_u5BB6_uFF1A" class="headerlink" title="RST复位报文段出现的原因很多，在网路编程中，也很难排查原因在哪？所以列出一些常见的原因，分享给大家："></a>RST复位报文段出现的原因很多，在网路编程中，也很难排查原因在哪？所以列出一些常见的原因，分享给大家：</h3><ul>
<li>端口未打开：如果服务器程序端口位打开，而客户端来进行连接。</li>
<li>请求超时：例如一个客户端连接服务器时，Connect系统调用返回时失败，出现错误信息，但是这个时候使用ping命令进行测试没有出现丢包现象，如果在使用抓包工具查看，客户端收到服务器端的同步报文段之后，发送了RST复位报文段，这就有可能是请求超时的原因</li>
<li>提前关闭：如果服务端关闭或者异常终止连接，而且由于网络故障原因，对方没有接收到结束报文段没这个时候客户端还维护着原来的连接，这个时候我们把服务器重新启动，但是次服务器已经没有任何该连接的信息了。如果此时客户端向服务器写一个数据，对方就会回应一个RST复位报文段</li>
<li>在一个已关闭的Socket上收到数据：这种情况看见的不多，比如说连接关闭后，网络中游离的数据包到达目标段，此时目标段发现这个连接已经关闭，复位报文段就会发送到另一个连接。</li>
<li>异常终止一个连接：在数据交换完成之后，发送数据报文段。</li>
<li>向处于LISTEN状态的端口发送数据：会收到对端发送的RST复位报文段</li>
</ul>
<h3 id="u4E86_u89E3_u4EE5_u4E0A_u5185_u5BB9_u6709_u52A9_u4E8E_u7F51_u7EDC_u7F16_u7A0B_u7684_u8C03_u8BD5_u3002"><a href="#u4E86_u89E3_u4EE5_u4E0A_u5185_u5BB9_u6709_u52A9_u4E8E_u7F51_u7EDC_u7F16_u7A0B_u7684_u8C03_u8BD5_u3002" class="headerlink" title="了解以上内容有助于网络编程的调试。"></a>了解以上内容有助于网络编程的调试。</h3><h1 id="TCP_u53EF_u9760_u4F20_u8F93_u673A_u5236"><a href="#TCP_u53EF_u9760_u4F20_u8F93_u673A_u5236" class="headerlink" title="TCP可靠传输机制"></a>TCP可靠传输机制</h1><h2 id="TCP_u8D85_u65F6_u91CD_u4F20"><a href="#TCP_u8D85_u65F6_u91CD_u4F20" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h2><p>如果网络异常救出出现超时或者丢包，TCP模块必须能够重传在超时时间内对方未收到的TCP报文段。</p>
<ul>
<li>TCP模块为每个TCP报文段维护一个重传定时器：该定时器在TCP报文段第一次被发送时启动，如果超时时间内没收到接收方的应答，TCP模块将重传TCP报文段，并重置定时器</li>
<li>如果超时，则进行重传，重新设置定时器</li>
</ul>
<h2 id="TCP_u62E5_u585E_u63A7_u5236"><a href="#TCP_u62E5_u585E_u63A7_u5236" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP模块的任务</p>
<ul>
<li>提高网络利用率</li>
<li>降低丢包率</li>
<li><p>拥塞控制</p>
<p>其中拥塞控制，还有TCP的流量控制，这种控制机制都是为了TCP的可靠传输设置的，拥塞控制的任务是确保子网能承载所到达的流量。这是一个全局性问题，涉及到各方面的行为（刚兴趣可以自己去搜索下，这里就不做过多介绍）。</p>
<p>关于拥塞控制我们进行详细的讲解：</p>
<p>###拥塞控制的反馈过程：</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150806104035106" alt="这里写图片描述"></p>
<p> 拥塞控制的最终受控变量是发送端向网络中一次连续写入的数据量，我们称为我们称为发送窗口。不过发送窗口最终以TCP报文段来发送数据，进而发送端口就限定了连续发送的TCP报文段的数量，如图所示，发送窗口被称为SWND，这些报文段的最大长度被称为MSS发送端需要合理的选择发送窗口，如果发送窗口太小，就会出现网络延迟现象，如果发送窗口过大，就容易导致网络拥塞。接收方可以通过接收通告收窗口来控制发送端的发送窗口，但是这看起来也不够，所以在发送端引入一个称为拥塞窗口的状态变量，拥塞窗口简称CWND，接收通告窗口简称RWND。图像中就显示了拥塞控制的闭环反馈控制。</p>
<p> ###几种拥塞控制的方法:</p>
<ul>
<li>TCP慢启动</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<h3 id="u6162_u542F_u52A8_uFF0C_u62E5_u585E_u907F_u514D_u56FE_uFF1A"><a href="#u6162_u542F_u52A8_uFF0C_u62E5_u585E_u907F_u514D_u56FE_uFF1A" class="headerlink" title="慢启动，拥塞避免图："></a>慢启动，拥塞避免图：</h3><p><img src="http://img.blog.csdn.net/20150806104111167" alt="这里写图片描述"></p>
<p>我们知道那个发送端维持一个拥塞窗口的状态变量，拥塞窗口简称CWND，拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化。CWND的处理原则就是只要网络中没有出现拥塞现象，拥塞窗口就在大一些，以便把更多的分组发送出去。只要网络中出现拥塞，拥塞窗口就减少一些。以减少注入到网络分组中的数量。</p>
<p>我们现在来分析拥塞控制的算法：</p>
<ul>
<li><p>慢启动：当主机开始发送数据时，如果把大量的字节注入到网络，那么就有可能引起网络拥塞。因为我们现在并不清楚网络的负载情况。所以比较好的方法就是自动去探测一下，由小到大满满增大拥塞窗口的数值，通常在刚刚开始发送报文段的时候，先把拥塞端口设置为一个最大报文段，而在每个在收到新的报文段的时候，把拥塞窗口的大小加1，按照指数规律增长，也就是增大一个最大报文段的数值。我们用同样的方法逐渐增大发送端的拥塞窗口。可以使分组注入到网络中的数据更加合理。</p>
<p>  对应到图示中，横坐标从0－&gt;3都是满启动的状态。我们为了防止因为增大造成的网络拥塞，我们还需要设置一个满启动的ssthresh值，关于慢启动的ssthresh用法就是如果拥塞窗口小于ssthresh值，就应用慢启动算法。如果拥塞窗口大于ssthresh值，就停止应用慢启动算法。而改用拥塞避免算法</p>
</li>
<li><p>拥塞避免：拥塞避免算法为了让拥塞窗口缓慢的增长，就是每经过一个往返的时间，就把发送方的拥塞窗口加1，而不是成倍增长，这样拥塞窗口是按照线性规律缓慢增长。对应到图像中就是那个明显的拐点以后，都是拥塞避免的算法执行。</p>
</li>
</ul>
<p>仅仅应用 慢启动和拥塞控制，不可能达到控制网络拥塞</p>
<h3 id="u63A5_u4E0B_u6765_u4ECB_u7ECD_u5FEB_u901F_u91CD_u4F20_uFF0C_u5FEB_u901F_u6062_u590D"><a href="#u63A5_u4E0B_u6765_u4ECB_u7ECD_u5FEB_u901F_u91CD_u4F20_uFF0C_u5FEB_u901F_u6062_u590D" class="headerlink" title="接下来介绍快速重传，快速恢复"></a>接下来介绍快速重传，快速恢复</h3><p>在很多情况下，TCP发送端都可以接受到重复的确认报文段，例如TCP报文段缺失等等，发送端如果连接接收到三个重复的确认报文段，就可以判断网络中发生了拥塞。这个时候使用快速重传，快速恢复算法。快速重传算法我先要求接受端每收到一个失去的报文到，就立即发送重传确认。</p>
<p><strong>拥塞发生或有三个处理不步骤：</strong></p>
<p>拥塞发生后的处理过程：</p>
<ul>
<li>收到三个重复的确认处理过程：当收到三个重复的报文段时，重新计算满启动的ssthresh值，就是将ssthresh值减半，然后立即重传重传报文段。</li>
<li>收到1个重复确认处理过程：将慢启动的ssthresh值减半后，开始执行拥塞避免算法，而不是刚刚提到的慢启动算法。</li>
<li>收到新数据后的处理过程：重新设置慢启动的ssthresh值，使得拥塞窗口等于当前设置的ssthresh值。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/03/TCP/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/03/TCP/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/03/IP/" title="IP协议总结" itemprop="url">IP协议总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lastdays" target="_blank" itemprop="author">Lastdays</a>
		
  <p class="article-time">
    <time datetime="2016-02-03T13:24:40.000Z" itemprop="datePublished"> 发表于 2016-02-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="IP_u534F_u8BAE_u662FTCP_u534F_u8BAE_u6808_u4E2D_u7684_u6838_u5FC3_u534F_u8BAE_uFF0C_u4E5F_u662F_u7F51_u7EDC_u7F16_u7A0B_u7684_u57FA_u7840_u4E4B_u4E00_u3002"><a href="#IP_u534F_u8BAE_u662FTCP_u534F_u8BAE_u6808_u4E2D_u7684_u6838_u5FC3_u534F_u8BAE_uFF0C_u4E5F_u662F_u7F51_u7EDC_u7F16_u7A0B_u7684_u57FA_u7840_u4E4B_u4E00_u3002" class="headerlink" title="IP协议是TCP协议栈中的核心协议，也是网络编程的基础之一。"></a>IP协议是TCP协议栈中的核心协议，也是网络编程的基础之一。</h1><h2 id="u7F51_u7EDC_u5C42_u6982_u8FF0"><a href="#u7F51_u7EDC_u5C42_u6982_u8FF0" class="headerlink" title="网络层概述"></a>网络层概述</h2><h3 id="IP_u670D_u52A1_u7279_u70B9_3A"><a href="#IP_u670D_u52A1_u7279_u70B9_3A" class="headerlink" title="IP服务特点:"></a>IP服务特点:</h3><p>IP协议为上层协议提供无状态，无连接，不可靠的服务。</p>
<ul>
<li>无状态：IP通信双方不同步状态传输信息，因此所有IP数据报的发送和接收都是相互独立的，这样也就造成了它无法处理乱序，重复的IP数据报。相对于面向连接而设定的，例如TCP协议，它能够自己处理乱序，重复的报文段。他递交给上层的内容绝对是有序的正确的。但是IP协议的状态也是有优点的，它简单高效，因为我们无需为保证它的状态而分配一些内核数据结构。</li>
<li>无连接：通信双方都不长久的维持对方的任何信息，那么就需要上层协议去指定传输的IP地址。</li>
<li>不可靠服务：不可靠指的是IP协议不能保证IP数据报完整并且准确的到达接收端。因此使用IP的上层协议需要自己做数据确认，超时重传等可靠传输机制。</li>
</ul>
<p>…</p>
<h3 id="IPv4_u5934_u90E8_u7ED3_u6784_3A"><a href="#IPv4_u5934_u90E8_u7ED3_u6784_3A" class="headerlink" title="IPv4头部结构:"></a>IPv4头部结构:</h3><p>图一：</p>
<p><img src="http://img.blog.csdn.net/20150809211053157" alt="这里写图片描述"></p>
<p>IPv4头部结构包含20个字节。另外最多包含40个选项字节。</p>
<ul>
<li>4位版本号：指定IP协议的版本</li>
<li>4位头部长度：标识有多少个四字节。</li>
<li>8位服务类型（TOS）：包括一个3位的优先权字段（现在已经被忽律），4位TOS字段（最小延时，最大吞吐量，最高可靠性，最小费用），1位保留字段。以上信息决定了IP协议的可弹性。</li>
<li>16位总长度（字节数）：整个IP数据报的长度。就是说IP数据报的最大程度就是2^16－1。因为MTU的限制。最大传输不可能达到这个值。</li>
</ul>
<p>＝＝＝＝＝＝分片传输实现原理＝＝＝＝＝＝＝＝＝</p>
<ul>
<li>16位标识别：唯一标识主机发送的每一个数据报。初始值有系统随机生成。每发送一个数据报，该值就＋1.因此同一个数据报的分片都具有相同的标识值</li>
<li><p>3位标志：</p>
<p>（1）第一位是有保留的</p>
<p>（2）第二位表示禁止分片（如果对这位进行了设置，IP模块将不会对数据报进行分片，所以可以想象一下我们刚才提到的，如果这个数据报的长度超过MTU，这段数据报就会被丢弃，返回ICMP差错报文）</p>
<p>（3）第三位表示等多分片（除了IP数据报的最后一个分片外，其他分片都设置为1）。</p>
</li>
<li>13位偏移：是分片相对原始IP数据报开始处的偏移。</li>
</ul>
<p>这三个字段协同工作行形成了IP分段的功能。</p>
<p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p>
<ul>
<li>8位生存时间（TTL）：它是数据报到达目的地前允许经过的路由跳数。在发送过程中，每经过一个路由，该值就减1.当TTL位0时，路由器会丢弃这个数据报，返回ICMP差错报文。它可以防止数据陷入路由循环。</li>
<li>8位协议涌来区分上层协议。ICMP位1，TCP为6，UDP位17</li>
<li>16位头部校验和：它是由发送端进行填充。接收端对其进行CRC校验算法，来检验头信息在传输过程中是否被损坏。</li>
<li>32位原端IP：表示发送端IP</li>
<li>32位目的IP：表示接受端IP</li>
<li>IPv4头部可变长的选项部分，最多包含401个字节，可选的IP选项包括：（1）纪录路由，（2）时间戳，（3）松散源路由选择，（4）严格路由选择   （这些的介绍会在以后进行分享）</li>
</ul>
<p>IP协议是TCP协议栈中的核心协议，也是网络编程的基础之一。<br>我们接着在<a href="http://blog.csdn.net/lastdays_l/article/details/47395921" target="_blank" rel="external">IP协议解读（一）</a>继续学习</p>
<h2 id="u7F51_u7EDC_u5C42_u4F5C_u7528"><a href="#u7F51_u7EDC_u5C42_u4F5C_u7528" class="headerlink" title="网络层作用"></a>网络层作用</h2><h3 id="IP_u5206_u7247_uFF1A"><a href="#IP_u5206_u7247_uFF1A" class="headerlink" title="IP分片："></a>IP分片：</h3><ul>
<li><p>IP数据报的长度超过帧的MTU时，将会被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，并且可能在传输过程中被多次分片。最终会在接收器上被IP模块重新组装。</p>
</li>
<li><p>在<a href="http://blog.csdn.net/lastdays_l/article/details/47395921" target="_blank" rel="external">IP协议解读（一）</a>中讲述了16位数据报标识、3位的标识，13位的片偏移给分片和重组提供了足够的信息。一个IP数据报的每个分片都具有自己的头部。他们具有相同的标识值，但具有不同的片偏移。</p>
</li>
<li><p>以太网的MTU位1500字节，因此它能携带的最大字节量位1480字节，因为IP头部包含20个字节。假如我们使用以太网帧传输用IP数据报封装的1481个字节的ICMP数据报。这个时候&gt;1480字节，所以就会出现分片现象</p>
<p>  ###那么1481个字节的数据+20字节的IP头部=1501字节的IP数据报=IP分片（1500字节）+IP分片（21字节）<br>  结构如图所示：</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150811121717075" alt="这里写图片描述"></p>
<p>从以上的图片我可以分析出来，ICMP头部的8个字节被分配到第一个分片中，其中1472字节的ICMP的数据也被分配到第一个分片中，这样IP头+ICMP头部结构+部分ICMP数据组成了最大的IP分片（1500字节），剩下的一个个字节的ICMP数据被分配到第二个IP分片中（21字节）</p>
<p>下面我们用实例演示：</p>
<p>我们使用ping命令指定每次发送的大小位1473个字节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com <span class="operator">-s</span> <span class="number">1473</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150811121838596" alt="这里写图片描述"></p>
<p>我们使用tcpdump命令抓取ping过程中的icmp数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -ntv -i eth0 icmp</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150811121920417" alt="这里写图片描述"></p>
<p>===============查看分析抓去结果=====================</p>
<p>结果如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150811122731873" alt="这里写图片描述"></p>
<p>从图片中我们可以看出，前两个数据报的ip分片id（标识值）都是27300，说明这两个是同一个分片，第一个分片的offset（偏移值）为0，第二个分片的offset（偏移值）为0位1480.根据信息显示，第一个ICMP占1480个字节，第二个长度为21.</p>
<h3 id="IP_u8DEF_u7531_u9009_u62E9_u673A_u5236_uFF1A"><a href="#IP_u8DEF_u7531_u9009_u62E9_u673A_u5236_uFF1A" class="headerlink" title="IP路由选择机制："></a>IP路由选择机制：</h3><p>路由选择是IP协议的核心任务，指定了发送数据报到目标路径的途径</p>
<p><img src="http://img.blog.csdn.net/20150811122637878" alt="这里写图片描述"></p>
<ul>
<li>当IP模块接受到来自网络驱动程序发来的IP数据报时，首先对头部进行CRC校验，确定这个数据包在传输过程中没有被损坏。</li>
<li>如果发现IP头部信息中带有<strong>源站选路</strong>选项，那么IP模块调用数据报转发子模块处理这个数据报。</li>
<li>如果这个IP数据报头部结构中目标IP地址是本机的IP地址或是广播地址，就是说明这个数据报是发送给本机的IP模块就必须根据数据报的头部结构协议字段将它发给哪个上层应用。</li>
<li>如果IP模块发现这个数据报不是发送给本机的，同样也掉中转发子模块处理这个数据报，转发子模块首先需要检验这个数据报是否被允许转发。不允许的话这个数据报就会被丢弃。允许的话数据报转发子模块将对这个数据报进行一系列的操作，然后将它交给IP数据报输出子模块。</li>
<li>其实呢，IP数据报应该发送到哪一个吓一跳路由，经过哪个网卡来发送，是<strong>计算吓一跳</strong>路由这个模块完成的。</li>
<li>IP模块实现数据报路由的核心数据结构就是<strong>路由表</strong>，这个表是按照目的IP进行分类。</li>
<li>IP输出队列中是所有等待发出的数据报。</li>
<li>虚线箭头是整个路由表的更新过程</li>
</ul>
<p>IP路由选择过程：</p>
<ul>
<li>查找完全匹配的主机地址，如果找到就是用该路由项，如果未找到，进入下一个步骤</li>
<li>查找相同网络ID的网络IP地址，如果找到就是用该路由项，如果未找到，进入下第三个步骤</li>
<li>选择默认路由项，这意味着下一跳的路由地址是网关</li>
</ul>
<h3 id="IP_u8F6C_u53D1_u8FC7_u7A0B_uFF1A"><a href="#IP_u8F6C_u53D1_u8FC7_u7A0B_uFF1A" class="headerlink" title="IP转发过程："></a>IP转发过程：</h3><p>路由器转发模块的执行过程如下：</p>
<ul>
<li>检查数据报头部的TTL值（TTL为0丢弃这个数据报）。</li>
<li>查看数据包的严格源路由的选择选项，如果被设置，检测数据报的目的IP地址是否和本机的某个IP地址相同，如果不是，发送一个ICMP差错报文。</li>
<li>给源端发送一个ICMP重定向报文（下一个文章分享）。</li>
<li>将TTL值减1</li>
<li>处理IP头部选项</li>
<li>如果有必要，执行IP分片操作</li>
</ul>
<h3 id="u8DEF_u7531_u8868_u66F4_u65B0_uFF1A"><a href="#u8DEF_u7531_u8868_u66F4_u65B0_uFF1A" class="headerlink" title="路由表更新："></a>路由表更新：</h3><p>路由表必须具备更新，反应网络中的连接的变化，这样IP模块才能准确，高效的转发数据报。</p>
<p>进行实例演示。</p>
<p>Linux下使用明route命令查看当前主机下的路由表信息。<br><img src="http://img.blog.csdn.net/20150811122852036" alt="这里写图片描述"></p>
<p>第一行表示子系统下的默认路由</p>
<p>使用route命令添加路由表</p>
<p><img src="http://img.blog.csdn.net/20150811123013217" alt="这里写图片描述"></p>
<p>删除对应项</p>
<p><img src="http://img.blog.csdn.net/20150811123030527" alt="这里写图片描述"></p>
<p>删除默认路由项，这样做的后果就是无法访问因特网。</p>
<p><img src="http://img.blog.csdn.net/20150811123044978" alt="这里写图片描述"></p>
<p>今天我们来介绍网络层中的ICMP协议</p>
<h2 id="ICMP_u62A5_u6587_u683C_u5F0F"><a href="#ICMP_u62A5_u6587_u683C_u5F0F" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h2><p>图一：</p>
<p><img src="http://img.blog.csdn.net/20150812131618110" alt="这里写图片描述"></p>
<p>从图片上我们可以分析出，前三位的字段都是固定的，8位类型字段，8位代码字段，16位校验和字段。其他字段因ICMP报文类型不同而不同。8位类型和8位代码一起决定了报文的类型。</p>
<h2 id="ICMP_u67E5_u8BE2_u683C_u5F0F"><a href="#ICMP_u67E5_u8BE2_u683C_u5F0F" class="headerlink" title="ICMP查询格式"></a>ICMP查询格式</h2><h3 id="ICMP_u67E5_u8BE2_u62A5_u6587_u5171_u67094_u79CD"><a href="#ICMP_u67E5_u8BE2_u62A5_u6587_u5171_u67094_u79CD" class="headerlink" title="ICMP查询报文共有4种"></a>ICMP查询报文共有4种</h3><ul>
<li>回送请求和回答：由主机和路由器向一个特定的主机和路由器发送询问，收到请求的主机必须给源主机发送回送应答报文，用来测试目标主机是否可达以及了解其他状态</li>
<li>时间戳请求和回答：它允许系统向另一个系统查询当前的时间，该ICMP的好处是他提供了毫秒级的分辨率。</li>
<li>掩码地址请求和回答：主机使用ICMP地址掩码地址请求报文可以向子网掩码服务器得到某个接口的地址掩码。系统广播他的ICMP请求报文。</li>
<li>路由器询问和通过报文：主机使用ICMP路由器询问连接在本网络上的路由器是否正常工作。</li>
</ul>
<h2 id="ICMP_u5DEE_u9519_u62A5_u6587"><a href="#ICMP_u5DEE_u9519_u62A5_u6587" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h2><h3 id="ICMP_u5DEE_u9519_u62A5_u6587_u5171_u67095_u79CD_uFF1A"><a href="#ICMP_u5DEE_u9519_u62A5_u6587_u5171_u67095_u79CD_uFF1A" class="headerlink" title="ICMP差错报文共有5种："></a>ICMP差错报文共有5种：</h3><ul>
<li>终点不可达：网络不可达，主机不可达，协议不可达，端口不可达，源路由失败</li>
<li>源站抑制：当路由器或主机因为拥塞丢弃数据包时，就向源站发送源站抑制报文，使源站知道应当将发送数据报的速度放慢。</li>
<li>时间超过：路由器收到生存时间为0的数据报时，除丢弃该数据报外还要向源站发送时间超时报文</li>
<li>参数问题差：当路由器的目的主机收到的数据报首部中的字段不正确的时候，丢弃该数据报，同时向源地址发送ICMP参数问题报文。</li>
<li>重定向报文：路由器将改变路由报文，将发送给主机，让主机知道，下一次的数据报应该发送给另一个路由器。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/03/IP/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/03/IP/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/03/Core Date/" title="iOS9 Core Data教学" itemprop="url">iOS9 Core Data教学</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lastdays" target="_blank" itemprop="author">Lastdays</a>
		
  <p class="article-time">
    <time datetime="2016-02-03T13:23:53.000Z" itemprop="datePublished"> 发表于 2016-02-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="u770B_u4E86_u4E00_u7BC7_u56FD_u5916_u7684_u6587_u7AE0_uFF0C_u5173_u4E8EiOS9_u7684Core_Data_u6559_u5B66_uFF0C_u5728_u8FD9_u91CC_u505A_u4E86_u4E00_u4E0B_u603B_u7ED3"><a href="#u770B_u4E86_u4E00_u7BC7_u56FD_u5916_u7684_u6587_u7AE0_uFF0C_u5173_u4E8EiOS9_u7684Core_Data_u6559_u5B66_uFF0C_u5728_u8FD9_u91CC_u505A_u4E86_u4E00_u4E0B_u603B_u7ED3" class="headerlink" title="看了一篇国外的文章，关于iOS9的Core Data教学，在这里做了一下总结"></a>看了一篇国外的文章，关于iOS9的Core Data教学，在这里做了一下总结</h1><h1 id="Core_Data__u6559_u5B66"><a href="#Core_Data__u6559_u5B66" class="headerlink" title="Core Data 教学"></a>Core Data 教学</h1><p>示例开源地址：<a href="https://github.com/MrLoong/LastDayCoreData" target="_blank" rel="external">LastDayCoreData</a></p>
<p>在这篇文章中我们将学习Core Data的系列教程，你将使用Swift2.0写你的Core Data。你将发现在Xcode中它是很容易上手的，从启动代码导师数据模型编辑器。在教程结束后，你会了解到：</p>
<ul>
<li>使用Xcode的model editor将你想存储在Core Data。</li>
<li>添加新的记录到 Core Data</li>
<li>从Core Data中读取一组数据</li>
<li>在表视图中显示所获取的结果</li>
</ul>
<p>你也将会了解Core Data背后的数据是什么，以及如何进行交互。OK，现在让我们来构建我的app吧。</p>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><p>打开你的Xcode新建一个iPhone工程，选择Single View Application template起名为HitList并且选择Use Core Data。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-2.png" alt=""></p>
<p>选中Use Core Data复选框后将会在AppDelegate.swift生成Core Data stack样本代码</p>
<p>Core Data stack由一组对象组成，方便于检索和保存Core Data的数据。有一个对象最为一个整体来管理Care Data的状态和数据模型等等。</p>
<p>这个示例程序的想法很简单。有一个被叫”hit list”的表视图。你可以在这个列表中添加名字，并且最终你将使用Core Data确保数据在各个环节之间。</p>
<p>点击Main.storyboard在Interface Builder.接下来点击Editor，选择Navigation Controller。具体操作如图所示:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-4.png" alt=""></p>
<p>返回Interface Builder，拖拽一个Table view。</p>
<p>接下来拖拽一个Bar Button Item将它放置到navigation bar。最终，起名为Add。就像这样</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-7.png" alt=""></p>
<p>当你每次点击Add的时候，一个包含文本信息字段的弹框将会出现在屏幕上显示。在那里你能够输入默认的名字到进入文本域。</p>
<p>如果你想知道原因，你可以不设置表示图的委托，这样就不会触发任何行为。</p>
<p>打开Assistant Editor拖拽table view到 ViewController.swift，在类中插入一个outlet：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-10.png" alt=""></p>
<p>起名为 tableview</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@IBOutlet weak var tableView: UITableView!</span><br></pre></td></tr></table></figure>
<p>同样将Add拖拽到ViewController.swift，创建一个action 命名为addName：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func addName(sender: AnyObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么现在你可引用表示图和按钮了。接下来就是建立表示图模型。在ViewContrroller.swift中添加一下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Insert below the tableView IBOutlet</span><br><span class="line">var names = [String]()</span><br></pre></td></tr></table></figure>
<p>names是一个可变的shtring类型的数组，在tableview中显示。</p>
<p>在viewDidLoad()中实现一下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func <span class="function"><span class="title">viewDidLoad</span></span>() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  title = <span class="string">"\"The List\""</span></span><br><span class="line">  tableView.registerClass(UITableViewCell.self,</span><br><span class="line">    <span class="keyword">for</span>CellReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里将建立一个标题，注册UITableViewCell在table view类中。table view将返回正确类型的cell</p>
<p>仍然在ViewController.swift，添加UITableViewDataSource,UITableViewDelegate</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Add UITableViewDataSource to class declaration</span><br><span class="line">class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate&#123;</span><br><span class="line">  //这里添加</span><br><span class="line">	tableView.dataSource = self</span><br><span class="line">	tableView.delegate = self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候Xcode会提示ViewCotroller不符合协议.实现data source方法修改这个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// MARK: UITableViewDataSource</span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">  numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">  <span class="built_in">return</span> names.count</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">  cellForRowAtIndexPath</span><br><span class="line">  indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> cell =</span><br><span class="line">  tableView.dequeueReusableCellWithIdentifier(<span class="string">"Cell"</span>)</span><br><span class="line"> </span><br><span class="line">  cell!.textLabel!.text = names[indexPath.row]</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你用过UITableView，这段代码看起来会很相似。第一个方法就是names数量。</p>
<p>第二个方法tableView(_:cellForRowAtIndexPath:)返回对cell对象。</p>
<p>不要现在就运行。首先你需要一个输入names的方法然后在table view中进行显示他们。</p>
<p>实现addName IBAction</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Implement the addName IBAction</span><br><span class="line">@IBAction func addName(sender: AnyObject) &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> alert = UIAlertController(title: <span class="string">"New Name"</span>,</span><br><span class="line">    message: <span class="string">"Add a new name"</span>,</span><br><span class="line">    preferredStyle: .Alert)</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> saveAction = UIAlertAction(title: <span class="string">"Save"</span>,</span><br><span class="line">    style: .Default,</span><br><span class="line">    handler: &#123; (action:UIAlertAction) -&gt; Void <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">      <span class="built_in">let</span> textField = alert.textFields!.first</span><br><span class="line">      self.names.append(textField!.text!)</span><br><span class="line">      self.viewWillAppear(<span class="literal">true</span>)</span><br><span class="line">      self.tableView.reloadData()</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> cancelAction = UIAlertAction(title: <span class="string">"Cancel"</span>,</span><br><span class="line">    style: .Default) &#123; (action: UIAlertAction) -&gt; Void <span class="keyword">in</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  alert.addTextFieldWithConfigurationHandler &#123;</span><br><span class="line">    (textField: UITextField) -&gt; Void <span class="keyword">in</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  alert.addAction(saveAction)</span><br><span class="line">  alert.addAction(cancelAction)</span><br><span class="line"> </span><br><span class="line">  presentViewController(alert,</span><br><span class="line">    animated: <span class="literal">true</span>,</span><br><span class="line">    completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次点击Add按钮的时候，这个方法该方法弹出文本域和两个按钮，保存和取消。</p>
<p>点击保存，将其名称插入到数组中，table view将重新加载数据并显示。</p>
<p>在这里，构建并且第一次运行我们的应用程序。点击顶部的Add按钮，将会插入一个弹框。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-12.png" alt=""></p>
<p>添加4个或者5个左右的数据，就是下面的样子</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-14.png" alt=""></p>
<p>你的table view将显示数据，但是并不能实现持久化，什么意思呢？就是说我们现在的数组数据是存放在内存中的，但是如果我们一旦强制退出应用程序或者重新启动你的设备，你的数组数据就会被销毁。</p>
<p>Core Data提供持久化，意思就是他可让数据保持为持久状态，尽管应用重新启动或者是重新运行。</p>
<p>你现在还没有添加任何Core Data。让我们来测试下，切换到Simulator，点击Shift+⌘+H,将会返回home界面。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-15.png" alt=""></p>
<p>看到HitList图标，点击它切换到应用，这些名字一样存在着。这跟我们刚才描述的不一样，为什么呢？</p>
<p>当你点击Home按钮的时候。这个时候操作系统会瞬间冻结所有当前在内存中的一切信息。包括我们的名称数组字符串。同样，当我们的应用切换回去的时候，操作系统会恢复过去的记忆，就像你从来没有离开过一样，意思就是我们的names被恢复了。</p>
<p>多任务模式早在iOS 4中推出。他们创造了iOS用户无缝体验，同时也添加了持续性的概念，这心真的存在吗？</p>
<p>不，这不是真的。如果你完全杀死应用程序或者关闭你的iPhone，你的names数组就会消失。你可以体验下，快速的双击Home。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-17.png" alt=""></p>
<p>在这里，向上拉动你的应程序，在这里就会将程序杀死了。这个时候反回Home，再一次点击你的应用程序，names就会消失。</p>
<p>以上展现的两种方式书有差异的，所以这里看来了解熟悉多任务模式是显而易见的。但是这个在用户的头脑中是没有什么区别的。用户不会在乎通过哪种方式切回到Home，或者切回到应用。</p>
<p>现在的问题就是怎么样让应用无论通过哪种方式返回都能够存在。</p>
<p>现在就到了我们要讲诉的东西了，实现真正的持久性，数据在一个应用中无论怎样都会存在着。</p>
<p>##数据建模</p>
<p>现在你知道如何检测持久性了，让我们开始Core Data的学习。你的目标很简单，就是持久化你输入的名字，重新启动后仍然存在这个应用程序中。</p>
<p>这这里，你已经了解了如何在内存中存储names名称。在这里你将使用Core Data代替那种方法。</p>
<p>第一步就是创建一个managed object model，就是意味着通过Core Data数据将在磁盘上。默认情况下，Core Data使用SQlite数据库作为持久化的存储，所以你可以想象数据模型看成数据库架构。</p>
<p>当你创建了工程的时候我们选择了Use Core Data，Xcode会自动创建一个数据模型文件叫做HitList.xcdatamodeld</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-19.png" alt=""></p>
<p>点击HitList.xcdatamodeld打开它，正如你所看到的，Xcode有自己的数据模型编辑器，就像如图所示那样</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-20.png" alt=""></p>
<p>这个数据模型有很多功能，让我们创建一个简单的数据实体。</p>
<p>在左下方点击 Add Entity创建一个新的实体，双击我们新创建的实体，并且改名为Person，就像这样：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-21.png" alt=""></p>
<p>你可能很想知道为什么数据模型编辑器使用”实体”，而不是简单的定义一个新类。你不久就会看到，Core Data的数据来源于自身的词汇表。以下有一些常见的书语你可能会遇到：</p>
<ul>
<li>在Core Data中一个entity是一个类的定义。举一个典型的例子就是员工和公司的例子。在关系型数据库中，一个实体对应一个表。</li>
<li>一个attribute是连接到特定实体信息的一部分。例如，一个员工可以拥有姓名，职位，工资等attribute。在数据库中attribute（属性）对应表中特定的字段。</li>
<li>relationship是多个实体之间的一个连接。</li>
</ul>
<p>现在你知道了什么是attribute，返回模型编辑并且添加一个attribute到Person中，选择Person，点击+。</p>
<p>建立一个name并且选择类型为String。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-22.png" alt=""></p>
<p>在Core Data包含很多种数据类型，String是其中的一种。</p>
<p>##保存数据到Core Data</p>
<p>在ViewCortroller.swift中 Import Core Data</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Add below <span class="string">"import UIKit"</span></span><br><span class="line">import CoreData</span><br></pre></td></tr></table></figure>
<p>在Objective-C你可能不得不手动链接框架，但是在Swift中，一个简单的Import语句就就可以让你在你的代码中使用API。</p>
<p>接下来，更换模型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将names变味people，并且将people类型改为NSManagedObject类型</span><br><span class="line">var people = [NSManagedObject]()</span><br></pre></td></tr></table></figure>
<p>接下来你存储的是Person实体而不是names，所以将数据模型更名为people，并且它现在是NSManagedObject类型而不是简单的String类型。</p>
<p>NSManagedObject被称为在Core Data中的单一对象。你必须使用它创建，修改，保存和删除操作你的持久数据。</p>
<p>就在刚刚你已经改变了视图的模型，你必须也要使用下面的代码替换原来的数据源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Replace both UITableViewDataSource methods</span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">  numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> people.count</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">  cellForRowAtIndexPath</span><br><span class="line">  indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">let</span> cell =</span><br><span class="line">    tableView.dequeueReusableCellWithIdentifier(<span class="string">"Cell"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">let</span> person = people[indexPath.row]</span><br><span class="line"> </span><br><span class="line">    cell!.textLabel!.text =</span><br><span class="line">      person.valueForKey(<span class="string">"name"</span>) as? String</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实通过比较来看其实最显著的变化在cellForRowAtIndexPath，仔细看看就能够发现其中的变化。</p>
<p>当然，你需要注意的地方还有就是你是如何从NSManagedObject抓去name属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell!.textLabel!.text = person.valueForKey(<span class="string">"name"</span>) as? String</span><br></pre></td></tr></table></figure>
<p>为什么用以上的方式呢？因为NSManagedObject并不知道在你的数据模型中name是如何被定义在你的数据模型中的，因此没有办法直接访问你的name属性。唯一的方法就是用过Core Data提供的key-value来读取，这种方式通常被叫做KVC。</p>
<p>我在这里同样也简单的介绍一下KVC吧。就是说如果你是一个新的iOS开发者可能不了解什么是KVC或者是key-vale编码。KVC就是Cocoa和Cocoa Touch的机制来访问一个对象的而属性间接的使用字符串来识别。在以上的情况下，KVC就像是一本字典。</p>
<p>接下来就是改变我们@IBAction addName方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> saveAction = UIAlertAction(title: <span class="string">"Save"</span>,</span><br><span class="line">  style: .Default,</span><br><span class="line">  handler: &#123; (action:UIAlertAction) -&gt; Void <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">let</span> textField = alert.textFields!.first</span><br><span class="line">    self.saveName(textField!.text!)</span><br><span class="line">    self.tableView.reloadData()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>看到上面我们有新添加了一个saveName方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func saveName(name: String) &#123;</span><br><span class="line">  //<span class="number">1</span></span><br><span class="line">  <span class="built_in">let</span> appDelegate =</span><br><span class="line">  UIApplication.sharedApplication().delegate as! AppDelegate</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> managedContext = appDelegate.managedObjectContext</span><br><span class="line"> </span><br><span class="line">  //<span class="number">2</span></span><br><span class="line">  <span class="built_in">let</span> entity =  NSEntityDescription.entityForName(<span class="string">"Person"</span>,</span><br><span class="line">    <span class="keyword">in</span>ManagedObjectContext:managedContext)</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> person = NSManagedObject(entity: entity!,</span><br><span class="line">    insertIntoManagedObjectContext: managedContext)</span><br><span class="line"> </span><br><span class="line">  //<span class="number">3</span></span><br><span class="line">  person.setValue(name, <span class="keyword">for</span>Key: <span class="string">"name"</span>)</span><br><span class="line"> </span><br><span class="line">  //<span class="number">4</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    try managedContext.save()</span><br><span class="line">  //<span class="number">5</span></span><br><span class="line">    people.append(person)</span><br><span class="line">  &#125; catch <span class="built_in">let</span> error as NSError  &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Could not save \(error), \(error.userInfo)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面都是什么呢？我们来分析下</p>
<ul>
<li>在你做svae操作之前，你需要先获取NSManagedObjectContext。你可以认为这是用来managed object context的。想进行保存对象到Core Data中需要两步，首先，你需要插入一个对象到managed object context中。然后提交，将该对象存储到磁盘中。Xcode其实已经产生一个通用的模板，当你选择Use Core Data的时候。这个默认的managed object context存在于application delegate中。要想引用它，你需要获取一个app delegate引用。</li>
<li>创建managed object context并且完成NSManagedObject的初始化，init(entity:insertIntoManagedObjectContext:).你可能会想到NSEntityDescription的所有相关东西</li>
<li>使用NSManagedObject，必须使用你建立的name，必须使用KVC，否则会出现崩溃现象。</li>
<li>你的提交的person被保存在磁盘中，注意save会抛出异常，这就是为什么我们需要使用try do。</li>
<li>接下来就要恭喜你已经成功并且安全的的实现了数据的持久化。仍然是当我们插入后将会重新加载视图</li>
</ul>
<p>这比使用一个字符串可能复杂的很多，但是并不是很复杂。这里的代码就是获取managed object context和entity，</p>
<p>构建并且运行，添加一些类似下面的名字。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-24.png" alt=""></p>
<p>如果你的数据已经在Core Data中存储，并且实现了数据的持久化，这个时候我们杀死我们的app，然后重现加载我们程序，等一下，发生了什么？table view是空的</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-26.png" alt=""></p>
<p>你存续到Core Data中的数据但是重新加载后并没有，仍然是空的，其实数据事实上在那里的等待着，你并没有显示它、</p>
<p>从Core Data中获取</p>
<p>要得到持久化的数据，你必须取出它。在ViewController.swift中天添加一个方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">override func viewWillAppear(animated: Bool) &#123;</span><br><span class="line">  super.viewWillAppear(animated)</span><br><span class="line"> </span><br><span class="line">  //<span class="number">1</span></span><br><span class="line">  <span class="built_in">let</span> appDelegate =</span><br><span class="line">  UIApplication.sharedApplication().delegate as! AppDelegate</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">let</span> managedContext = appDelegate.managedObjectContext</span><br><span class="line"> </span><br><span class="line">  //<span class="number">2</span></span><br><span class="line">  <span class="built_in">let</span> fetchRequest = NSFetchRequest(entityName: <span class="string">"Person"</span>)</span><br><span class="line"> </span><br><span class="line">  //<span class="number">3</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">let</span> results =</span><br><span class="line">      try managedContext.executeFetchRequest(fetchRequest)</span><br><span class="line">    people = results as! [NSManagedObject]</span><br><span class="line">  &#125; catch <span class="built_in">let</span> error as NSError &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Could not fetch \(error), \(error.userInfo)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中做了什么？</p>
<ul>
<li>就像刚才说的，在做一些操作前你需要获取一个managed object context。从delegate中引用managed object context.</li>
<li>根据名字就能看出来，NSFetchRequest就是返回的数据。</li>
<li>executefetchrequest()返回满足managed objects读取请求中指定的标准数组。</li>
</ul>
<p>构建并且重新运行，就能发现你想要的效果了</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/CoreData2-28.png" alt=""></p>
<p>现在你就可以随意的测试了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/03/Core Date/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/03/Core Date/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="MrLoong" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5848341536&verifier=b03f6446&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 我叫Lastdays，一个喜欢白菜的90后，单线程的iOS开发男孩. <br/>
			这是我的博客，我在这里分享我的一切.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5848341536" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/MrLoong" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Lastdays">Lastdays</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?359a67e4b1b43ca291f946419c2423c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
